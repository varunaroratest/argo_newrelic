name: Apply Appsets

on:
  workflow_dispatch:
  # runs when a file in the instances folder path gets updated on the main branch
  push:
    branches:
      - main
    paths:
      - node/*

permissions:
  id-token: write
  contents: read

env:
  KUBECONFIG: "/home/runner/work/_temp/kubeconfig_1646411637463"

jobs:
  Get_File_Data:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.listFileChanges.outputs.matrix }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Get's all the changed files within the instances folder.
      - name: Grab File Changes
        id: changed-files
        uses: tj-actions/changed-files@v35
        with:
          json: true
          files: |
            instances/**

      - name: List All Changed Files
        id: listFileChanges
        run: |
          echo "Changed Instance Files", ${{ steps.changed-files.outputs.all_changed_files }}

          touch temporaryFile.json
          jq 'reduce .[] as $entry ({}; ($entry | split("/") ) as $names | $names[1:-1] as $p | setpath($p; getpath($p) + [$names[-1]]) )' <<< ${{ steps.changed-files.outputs.all_changed_files }} > temporaryFile.json
          arrayOfArgoInstances=$(jq -c -rS 'to_entries | map_values(.value + { argoInstance: .key })' temporaryFile.json)

          store_matrix=$(echo "{\"include\":$arrayOfArgoInstances}")
          echo "matrix=$store_matrix" >> $GITHUB_OUTPUT

  Update_Each_Cluster:
    runs-on: ubuntu-latest
    needs: Get_File_Data
    if: ${{ !failure() }}
    strategy:
      matrix: ${{ fromJson(needs.Get_File_Data.outputs.matrix)}}
    steps:
      - uses: actions/checkout@v3
      - uses: azure/setup-kubectl@v3
        id: install
     
      - name: Set up kubelogin for non-interactive login
        uses: azure/use-kubelogin@v1
        with:
          kubelogin-version: "v0.0.24"      

      - name: Run Commands In Cluster
        run: |
          echo "Arrrr, here there be matrices", '${{toJson( matrix )}}'         
          appSetArray='${{toJson(matrix.applicationSets)}}'

          ### APPLICATION SET Logic
          if [ -z "${{matrix.applicationSets}}" ]; then
            echo "No applicationSets set. Skipping"
          else
            if [ -z "$(echo $appSetArray | jq -r '.[]')" ]; then
              echo "applicationSets array is empty. No updates needed"
            else
              for i in $(echo $appSetArray | jq -r '.[]'); do
                echo "File to run command against: ", $i
                pwd
                if [[ ${{ matrix.argoInstance }} =~ .*"argocd-internal".* ]]; then
                  cd node/k8/applicationSets
                  pwd
                  echo "Command running: kubectl apply -f $i"
                  kubectl apply -f $i
                  cd ../../../
                elif [[ ${{ matrix.argoInstance }} =~ .*"argocd-uat".* ]]; then
                  echo "UAT update applicationSets"
                  cd node/k8/applicationSets
                  pwd
                  echo "Command running: kubectl apply -f $i"
                  kubectl apply -f $i
                  cd ../../../
                elif [[ ${{ matrix.argoInstance }} =~ .*"argocd-prod".* ]]; then
                  echo "PROD update applicationSets"
                  cd node/k8/applicationSets
                  pwd
                  echo "Command running: kubectl apply -f $i"
                  kubectl apply -f $i
                  cd ../../../
                elif [[ ${{ matrix.argoInstance }} =~ .*"argocd-tooling".* ]]; then
                  echo "TOOLING update applicationSets"
                  cd node/k8/applicationSets
                  pwd
                  echo "Command running: kubectl apply -f $i"
                  kubectl apply -f $i
                  cd ../../../
                fi
              done
            fi
          fi
